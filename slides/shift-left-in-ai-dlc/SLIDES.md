---
marp: true
theme: default
paginate: true
header: "コードレビューを最後の砦にするな"
footer: ""
style: |
  section {
    font-family: 'Noto Sans JP', 'Hiragino Sans', sans-serif;
  }
  section.title {
    text-align: center;
    justify-content: center;
  }
  section.title h1 {
    font-size: 2.2em;
  }
  section.title h2 {
    font-size: 1.2em;
    color: #666;
  }
  blockquote {
    border-left: 4px solid #e74c3c;
    padding-left: 1em;
    color: #555;
    font-style: italic;
  }
  table {
    font-size: 0.85em;
  }
  strong {
    color: #e74c3c;
  }
  code {
    font-size: 0.9em;
  }
---

<!-- _class: title -->
<!-- _paginate: false -->

# コードレビューを最後の砦にするな

## AI駆動開発時代のシフトレフト戦略

---

# プロフィール

![bg right:30% contain](./images/self-profile.jpg)

## 加藤潤一

**経歴**
- 10歳からプログラミング開始
- 2014-2024年: kubell（旧Chatwork）
- 2025年1月: 独立（IDEO PLUS合同会社 代表）

**専門分野**
- ドメイン駆動設計（DDD）
- 関数型プログラミング
- 分散システム設計

15年以上のDDD実践経験 | Chatworkの大規模リアーキテクチャを主導

---

# 今日のテーマ

> レビューが辛いのは、レビューのせいじゃない。

AI駆動開発時代に求められるのは、**開発プロセス全体の再設計**です。

本セッションでは、実プロジェクト（Rustアクターランタイム fraktor-rs）での
実践例をもとに、具体的なシフトレフト戦略を紹介します。

---

# よく聞く声

- 「AIが書いたコード、レビューが大変になった」
- 「生成量が増えて、追いつかない」
- 「AIのコード、微妙に意図と違う」
- 「レビューで指摘しても同じミスが繰り返される」

---

# 本当にAIのせい？

レビュー負荷が増大した原因を整理してみる

| 原因 | 本質的な問題 |
|------|-------------|
| 大量のコードが生成される | 要件の粒度が大きすぎる |
| 意図と違うコードが出る | 仕様が定義されていない |
| 同じ指摘を繰り返す | ルールが機械的に強制されていない |
| 設計が一貫しない | AIへの制約が不足している |

---

# コードレビューに何を期待しているか

## レビューで本来やるべきこと
- 設計判断の妥当性
- ビジネスロジックの正しさ
- アーキテクチャとの整合性

## レビューに押し付けられていること
- 命名規約の確認
- コーディングスタイルの統一
- 仕様との整合性チェック
- 既存パターンとの一致確認

---

# シフトレフトとは

```
従来:  要件 → 設計 → 実装 → テスト → レビュー ← ここで品質確認
                                           😰

シフトレフト:
       要件 → 設計 → 実装 → テスト → レビュー
       ↑      ↑      ↑      ↑
       品質    品質    品質    品質
       確認    確認    確認    確認
```

**品質保証を上流工程に移動する**

---

# AI駆動開発におけるシフトレフト

5つのレイヤーで品質を左にシフトする

1. **要件の分割と絞り込み**
2. **仕様駆動開発（Spec-Driven Development）**
3. **エージェントへのルール注入**
4. **カスタムリンター・静的解析**
5. **コードレビュー** ← 最後の砦ではなく最終確認

---

<!-- _class: title -->

# レイヤー1: 要件の分割と絞り込み

---

# 要件の規模感をコントロールする

最初から適切な粒度は分からない。**初回は外れることが多い。**

- 見積もりが外れたら終わりではなく、**そこから学習する**
- フィボナッチの相対見積もりで規模感を揃える
- 大きすぎたら分割し、次のスプリントで再見積もり

**これはスクラムで僕らがやってきたことと全く同じ。**
AIだからといって、このプロセスをサボってはいけない。

---

# 要件分割の粒度

fraktor-rs では**フィーチャー単位**で要件を定義している

```
要件（フィーチャー単位）      ← 人間が定義・見積もり
  例: "distributed-pubsub"
  例: "graphstage-core-execution"
  例: "cluster-membership-gossip-topology"
        ↓
タスク分解（仕様駆動で分割）  ← AIと人間で共同分解
  例: ClosedShape, Flow::from_function, ...
```

人間が出す要件はフィーチャー単位。
型・関数レベルへの分割は**仕様駆動のタスク分解フェーズ**で行う。

---

# 最初の一手: 何から作るか

分割したとして、**最初に何を作るか**が最も難しい

## 2つのアプローチ

**1. MVPで全体性を担保する**
- 後から追加が困難な機能セットを最初に作る
- 骨格（アーキテクチャの背骨）を先に通す

**2. コアロジックファースト**
- 外部依存のないコアロジックを先に作り、インフラは後から差し込む
- DDDならドメイン層、ライブラリなら純粋なアルゴリズム層

---

# 実例: fraktor-rs の core ファースト

fraktor-rs は `core`（no_std）→ `std`（Tokio等）の順で構築

```
modules/actor/src/
├── core/          ← 最初に作る（外部依存なし）
│   ├── actor/        純粋なアクターモデル
│   ├── supervision/  監視戦略
│   ├── messaging/    メッセージング
│   └── ...           DBもネットワークも不要
│
└── std/           ← 後から差し込む（実行環境依存）
    ├── tokio/        Tokioランタイム統合
    └── ...           プラットフォーム固有の実装
```

**コアの正しさを外部依存なしで検証してから、外側を足す**

---

<!-- _class: title -->

# レイヤー2: 仕様駆動開発

---

# AIにコードを書かせる前に

> 「何を作るか」を定義せずに「作って」と言っていないか？

仕様がなければ：
- AIは「それっぽい」コードを生成する
- レビュアーは「何が正しいか」の基準がない
- 指摘が主観的になる

---

# cc-sddを使った仕様駆動開発


---

# cc-sdd: プロジェクトのステアリング

既存コードがある場合、以下のコマンドを実行する

```bash
# Step 0: AIが既存プロジェクトコンテキストを学習
/kiro:steering
```

`.kiro/steering/` に置くプロジェクト知識をAIが常時参照する

| ファイル | 内容 |
|---------|------|
| `product.md` | プロダクトビジョン、価値提案、ユースケース |
| `tech.md` | 技術スタック、モジュール構成、設計判断 |
| `structure.md` | ディレクトリ構造、命名規約、依存方向 |

AIが「このプロジェクトは何を目指しているか」を理解した上でコードを書く

---

# cc-sdd: 要件定義フェーズ

```bash
# Step 1: 仕様の初期化
/kiro:spec-init distributed-pubsubを実装する

# Step 2: 要件定義（AIが質問し、人間が回答・承認）
/kiro:spec-requirements distributed-pubsub
```

---

# cc-sdd: 生成される要件の例

AIが生成し、人間が承認する要件ドキュメント（実例から抜粋）

```markdown
### 要件1: トピック購読と送達
**目的:** トピック単位で購読と送達を行い、
分散配置でも同一のPubSub体験を得たい。

#### 受け入れ条件
1. 購読要求が起きたとき、購読を登録しなければならない
2. 購読解除要求が起きたとき、送達を停止しなければならない
3. メッセージ公開が起きたとき、購読者へ送達しなければならない
4. 購読者が存在しないならば、観測できるようにしなければならない
```

**「〜しなければならない」形式で、検証可能な受入条件を定義する**

---

# cc-sdd: 設計フェーズ

```bash
# Step 3: 設計（AIが設計、人間が検証・承認）
/kiro:spec-design distributed-pubsub

# Step 4: 設計の検証(品質ゲート)
/kiro:validate-design distributed-pubsub
```

---

# cc-sdd: 生成される設計の例

AIが生成する設計ドキュメント（実例から抜粋）

```markdown
## 目標
- トピック購読/解除/公開のAPIを提供
- バッチ条件で配送を制御
- トポロジ更新に追従し、到達不能ノードへの配送を停止

## 非目標
- Exactly-once 配送や永続キュー
- 複数クラスタ間のフェデレーション
- コンテンツベースのフィルタリング
```

**「非目標」の明示がスコープ逸脱を防ぐ**

---

# cc-sdd: 設計の要件トレーサビリティ

要件と設計コンポーネントの対応を明示する

```markdown
## 要件トレーサビリティ
| 要件 | 対応コンポーネント |
|------|------------------|
| 購読/送達の正当性 | PubSubApi, TopicActor |
| バッチ条件と個別配送 | BatchingProducer |
| 受理/拒否と公開制御 | PubSubPublisher |
| トポロジ追従 | ClusterEvent, DeliveryActor |
| 観測性とメトリクス | PubSubMetrics, EventStream |
```

**要件 → 設計の追跡可能性が、レビューの論点を明確にする**

---

# cc-sdd: タスク分解フェーズ

```bash
# Step 5: タスク分解（実装タスクに分解）
/kiro:spec-tasks distributed-pubsub
```

---

# cc-sdd: 実装フェーズ

```bash
# Step 6: TDDで実装
/kiro:spec-impl distributed-pubsub

# Step 7: 実装の検証
/kiro:validate-impl distributed-pubsub
```

**各フェーズで人間がゲートを設け、AIの暴走を防ぐ**

---

# もっと軽量なプロセスもある

---

# 軽量な制約カード

重厚な仕様書ではなく、**AIの解空間を絞るチェックリスト**

```markdown
# streams-phase1-trivial-gaps
status: active

## Intent
6つのtrivialなギャップを実装する
```

---

# 制約カード: MUST / MUST NOT

```markdown
## MUST
- TDD（テストファースト）
- ci-check.sh が全パス

## MUST NOT
- Attributes system の導入
- KillSwitch trait の抽出

## Tasks
- [ ] ClosedShape
- [ ] Flow::from_function
- [ ] KillSwitches::shared / single
```

**散文の仕様書ではなく、AIがチェック可能な制約リスト**

---

# 仕様があるとレビューが変わる

## 仕様なし
- 「この実装で合ってる？」（レビュアーが仕様を推測）
- 「ここ、こうした方がいいんじゃない？」（主観的）

## 仕様あり
- 「制約カードのMUSTを満たしているか？」（客観的）
- 「受入テストはPassしているか？」（検証可能）
- 「MUST NOTに逸脱していないか？」（スコープガード）

**レビューが「判断」から「検証」に変わる**

---

<!-- _class: title -->

# レイヤー3: エージェントへのルール注入

---

# AIは「教科書的に正しい」コードを書く

しかし、プロジェクト固有のパターンは知らない

- 命名規約
- エラー処理のスタイル
- アーキテクチャの層構造
- 使用するライブラリ・パターン

→ **レビューで毎回指摘する羽目になる**

---

# ルール注入の3層構造

| 層 | 仕組み | 役割 | 例 |
|----|--------|------|-----|
| 1 | CLAUDE.md | プロジェクト全体の方針 | 言語、設計哲学、CI手順 |
| 2 | Rules | ファイルパターン別の規約 | 不変性、命名、CQS |
| 3 | Skills | 特定タスクの専門知識 | 型設計、ギャップ分析 |

fraktor-rs の実装：
- **CLAUDE.md**: 30行の簡潔な方針（日本語、Less is more、YAGNI）
- **Rules**: 13個（共有8 + Rust固有5）
- **Skills**: 31個（プロジェクト固有含む）

---

# ルールの実例: learning-before-coding

```markdown
# コーディング前の学習

新しいコードを書く前に既存の実装を分析する。

## 必須ワークフロー
1. 類似コードの特定（同じレイヤー、同じ種類）
2. 2〜3個の類似実装を分析
3. パターンに従って実装

## 禁止事項
- プロジェクトが直接クラスなのにインターフェースを追加
- 手動DIなのにDIフレームワークを使用
- コメントがないのにJSDocを追加
```

**「既存のコードベースこそがプロジェクト規約のドキュメント」**

---

# ルールの実例: Rust固有ルール

fraktor-rs では言語固有の設計ルールも定義

| ルール | 内容 |
|--------|------|
| immutability-policy | `&mut self` 優先、interior mutability は原則禁止 |
| cqs-principle | Query は `&self` + 戻り値、Command は `&mut self` |
| naming-conventions | Manager/Util/Service 等の曖昧サフィックス禁止 |
| type-organization | 1公開型 = 1ファイル（例外条件も明文化） |
| reference-implementation | Pekko/protoactor-go からの移植ルール |

**型シグネチャ自体が設計意図を表現する**

---

# プロジェクト固有のスキル

汎用スキルだけでなく、**プロジェクト固有のスキル**が威力を発揮する

| スキル | 用途 |
|--------|------|
| designing-fraktor-shared-types | 共有型の設計支援（ArcSharedパターン） |
| creating-fraktor-modules | 7つのDylintルールに準拠したモジュール生成 |
| reviewing-fraktor-types | 過剰設計チェック（参照実装の1.5倍ルール） |
| pekko-gap-analysis | Pekko との差分分析と優先度付け |

**AIに「このプロジェクトの専門家」としての知識を与える**

---

# ルール注入の効果

| 観点 | ルールなし | ルールあり |
|------|-----------|-----------|
| 命名 | バラバラ | 統一される |
| 構造 | AIの好み | プロジェクトに準拠 |
| パターン | 教科書的 | 既存コードと一致 |
| レビュー指摘 | 毎回同じ | 大幅に減少 |

**「同じ指摘を繰り返す」問題の根本解決**

---

<!-- _class: title -->

# レイヤー4: カスタムリンター・静的解析

---

# 人間がレビューで指摘すべきでないもの

- コーディングスタイル → **フォーマッター**
- 型安全性 → **型チェッカー**
- 命名規約 → **カスタムリンター**
- 構造パターン → **カスタムリンター**
- セキュリティ → **静的解析**

**機械的に検出できるものは、機械に任せる**

---

# 実例: fraktor-rs の8つのDylintリンター

| リンター | 強制する設計ルール |
|---------|------------------|
| type-per-file-lint | 1ファイル1公開型 |
| mod-file-lint | mod.rs 禁止（2018モジュール規約） |
| module-wiring-lint | FQCN import 強制 |
| tests-location-lint | テストは `<name>/tests.rs` に配置 |
| use-placement-lint | use 文はファイル先頭 |
| rustdoc-lint | rustdocは英語、コメントは日本語 |
| cfg-std-forbid-lint | coreモジュールで `#[cfg(feature="std")]` 禁止 |
| ambiguous-suffix-lint | Manager/Util/Service 等の命名禁止 |

---

# AIエージェント向けリンターの特徴

通常のリンターとの決定的な違い：**エラーメッセージがAIへの修正指示**

```
// 通常のリンター
❌ "Naming convention violation"

// AI向けリンター（fraktor-rs の type-per-file-lint）
✅ "このファイルには複数の公開型が含まれています。
    PublicStruct1 と PublicStruct2 はそれぞれ別ファイルに
    分離してください。ファイル名は snake_case の型名に
    一致させてください。"
```

**AIが自律的に修正できるエラーメッセージ設計**

---

# Pre-Edit Lint: 編集前にリンターを実行する

fraktor-rs 独自のプラクティス

```bash
# ステップ1: 編集する前にリンターを実行
./scripts/ci-check.sh dylint -m actor

# ステップ2: 失敗したルールだけ読む（ルール全部は読まない）

# ステップ3: 違反を修正してからコードを書く

# ステップ4: 全タスク完了後
./scripts/ci-check.sh all
```

**構造的な問題を「書く前」に検出し、修正コストを最小化する**

---

# 自動化のピラミッド

```
           /\
          /  \        ← コードレビュー（人間の判断）
         /    \          設計妥当性・ビジネスロジック
        /------\
       /        \     ← カスタムリンター 8個 + Clippy
      /          \       命名・構造・モジュール規約
     /------------\
    /              \  ← Rules 13個 + Skills 31個
   /                \    不変性・CQS・既存パターン準拠
  /------------------\
 /                    \← 制約カード + Steering
/______________________\  要件定義・受入基準・プロダクトビジョン
```

**下層が堅固なほど、レビューで議論すべきことが減る**

---

<!-- _class: title -->

# まとめ: 開発プロセスの再設計

---

# シフトレフト戦略の全体像

| レイヤー | やること | fraktor-rs での実装 |
|---------|---------|-------------------|
| 要件分割 | タスクを小さく絞り込む | Kiro の3フェーズ承認制 |
| 仕様定義 | 制約カードで基準を明確化 | `.constraints/*.md` |
| コンテキスト | AIに永続的知識を与える | Steering ドキュメント |
| ルール注入 | Rules/Skillsで規約を強制 | 13 Rules + 31 Skills |
| 自動検査 | カスタムリンター | 8 Dylint + Clippy |
| レビュー | 設計判断に集中 | **本来の役割に集中** |

---

# fraktor-rs の実績

| 指標 | 数値 |
|------|------|
| 完了した仕様 | 32件（`.kiro/archive/`） |
| ルール | 13個（共有8 + Rust固有5） |
| スキル | 31個（うちプロジェクト固有4個） |
| カスタムリンター | 8個（Dylint） |
| CI チェック項目 | 7カテゴリ（format, lint, dylint, clippy, test, doc, embedded） |

**32件の仕様を仕様駆動で実装し、レビュー負荷を最小化**

---

# レビュアーが集中すべきこと

## 自動化で排除した後に残るもの

- この設計判断は妥当か？
- ビジネスロジックは正しいか？
- 参照実装との乖離は許容範囲か？
- セキュリティ上の懸念はないか？
- 過剰設計になっていないか？（型数が参照の1.5倍を超えていないか）

**これこそが人間にしかできないレビュー**

---

# 実践のステップ

1. **まず**: CLAUDE.md / Rulesを整備する（即効性が高い）
2. **次に**: Steeringドキュメントでプロジェクト知識を整理する
3. **そして**: 要件を小さく分割し、制約カードで仕様化する
4. **さらに**: カスタムリンターで機械的チェックを自動化する
5. **加えて**: プロジェクト固有のスキルを作成する
6. **最後に**: レビュープロセスを再定義する

---

# 最後に

> レビューが辛いのは、レビューのせいじゃない。

AI駆動開発時代のコードレビューは、**最後の砦**ではなく**最終確認**であるべき。

そのために必要なのは、レビューの改善ではなく、**開発プロセス全体の再設計**。

品質は上流で作り込む。

---

<!-- _class: title -->

# ありがとうございました

ご質問・ご意見をお待ちしています
